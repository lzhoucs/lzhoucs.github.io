---
layout:     post
title:      ES6 Notes
date:       2016-04-24
summary:    ES6 study notes.
categories: tech javascript
tags:       ES6 ES2015 JavaScript
---

ES6(a.k.a ES2015) has been around for some time. Although it is fully backward compatible with previous version
of JavaScript - ES5 which has been around for decades, there's quite some new syntax and features introduced in ES6
that is exciting on one hand, but can easily get wrong on the other hand. This posts is my study notes on ES6.

#### let for block scoping

`let` defines block scope variables, which can be accessed in a nested scope just like `var`. The following code outputs `12`:
{% highlight javascript %}

'use strict';
function updateProductId() {
  productId =12;
}
let productId =null;

updateProductId();
console.log(productId);

{% endhighlight %}

##### Unlike `var`, `let` is block scoped.

In the following example, every time the for loop runs, a new `i` is declared. Thurs each function gets its own copy of `i`.
The code outputs `0`:

{% highlight javascript %}

'use strict';
let updateFunctions =[];
for (let i =0; i <2; i++){
  updateFunctions.push(function () {returni; });
}
console.log(updateFunctions[0]());

{% endhighlight %}

Whereas in the following example, `var i` is function scoped and hoisted. Each function gets the same `i`. So the code outputs `2`

{% highlight javascript %}

'use strict';
let updateFunctions =[];
for (var i =0; i <2; i++){
  updateFunctions.push(function () {returni; });
}
console.log(updateFunctions[0]());

{% endhighlight %}

#### An arrow function is not a `function`

##### Unlike traditional `function`, an arrow function is not 'bindable'.

The following code outputs `123` rather than `456`:

{% highlight javascript %}
var o1 = {
  number: 123,
  getArrowFunc: function() {
    return () => console.log(this.number);
  }
};

var o2 = {
  number: 456
};
o1.getArrowFunc().bind(o2)();

{% endhighlight %}

##### Unlike `function`, an arrow function is not 'callable'.

Same as above, the following code outputs `123` rather than `456`:

{% highlight javascript %}

var o1 = {
  number: 123,
  getArrowFunc: function() {
    return () => console.log(this.number);
  }
};

var o2 = {
  number: 456
};
o1.getArrowFunc().call(o2);

{% endhighlight %}

##### Unlike `function`, an arrow function doesn't has a `prototype`.

The code below outputs `false`:
{% highlight javascript %}

'use strict';
var getPrice =() =>5.99;
console.log(getPrice.hasOwnProperty("prototype"));

{% endhighlight %}

#### Default Parameters

##### Default parameters have access to any variables in the context.

In the following example, `price` and `baseTax` can be accessed when defining another default parameter:

{% highlight javascript %}

'use strict';
var baseTax=0.07;
var getTotal=function(price, tax=price *baseTax) {
  console.log(price +tax);
};

{% endhighlight %}

##### Default parameter doesn't count as the actual parameter passed in.

The following code outputs `1` instead of `2`:

{% highlight javascript %}
'use strict';
var getTotal = function(price, tax=0.07){
  console.log(arguments.length);
};
getTotal(5.00);
{% endhighlight %}

##### Default parameters have orders and are not hoisted.

The following example causes a `SyntaxError` because adjustment is used before it is defined:

{% highlight javascript %}
'use strict';
var getTotal = function(price = adjustment, adjustment = 1.00){
  console.log(price + adjustment);
};
getTotal();
{% endhighlight %}

However the following similar example is valid and outputs `6`. And this is because JavaScript
is a dynamic language that doesn't do the compile time check, and at run time, the lookup for `adjustment`
is skipped in this case since an actual parameter is passed in and used.

{% highlight javascript %}
'use strict';
var getTotal = function(price = adjustment, adjustment = 1.00){
  console.log(price + adjustment);
};
getTotal(5);
{% endhighlight %}

### The `Rest` Parameter

The concept is similar to Java's [Arbitrary Number of Arguments](http://docs.oracle.com/javase/tutorial/java/javaOO/arguments.html#varargs).

#### The 'Rest' parameter is always an array.

The following code outputs `[]`:

{% highlight javascript %}
'use strict';
var showCategories = function (productId, ...categories) {
  console.log(categories);
};
showCategories(123);
{% endhighlight %}

##### Unlike default parameters, the 'Rest' parameter doesn't count as a parameter defined on the function signiture.

The following code outputs `1`:

{% highlight javascript %}
'use strict';
var showCategories = function (productId, ...categories) {};
console.log(showCategories.length)
{% endhighlight %}

##### Just like default parameters, the 'Rest' parameter doesn't count as a actual parameter passed in.

The following code outputs the number of actual parameters passed in, which is `3`
{% highlight javascript %}
'use strict';
var showCategories = function (productId, ...categories) {
  console.log(arguments.length);
};
showCategories(123, 'c1', 'c2')
{% endhighlight %}

### The 'Spread' operator

`...` is introduced in ES6 as the `Spread` operator.

#### `...` works not only with array, but with strings too.

The `...` breaks the string into a series individual characters, so the output is the maximum character `4`:
{% highlight javascript %}
'use strict';
var maxCode = Math.max(..."43210");
console.log(maxCode);
{% endhighlight %}

### Object Literal Extensions

An object literal is a list of zero or more pairs of property names and associated values of an object, enclosed in curly braces `{}`. In ES6, object
literals are extended with new features.

#### Like arrow functions, `this` in a shorthand function refer to the context the function being called.

For example, the following code outputs `5.99` rather than `7.99`:
{% highlight javascript %}

'use strict';
var price = 5.99;
var productView = {
  price: 7.99,
  calculateValue() {
    return this.price;
  }
};
console.log(productView.calculateValue());
{% endhighlight %}

So we need to keep in mind that the shorthand functions are not exactly the same thing as the traditional functions. The same goes for arrow functions.


